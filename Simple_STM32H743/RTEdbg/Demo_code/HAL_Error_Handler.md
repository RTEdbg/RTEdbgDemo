# Logging Calls to the STM HAL Error_Handler()

The demonstration code illustrates a non-intrusive method of logging essential debugging information, particularly the identity of the function that invokes Error_Handler(). This approach is advantageous because it does not require any modifications to the Error_Handler() implementation or the boilerplate code automatically generated by the STM32CubeMX code generator, which typically includes calls to Error_Handler() in the initialization routines.

Programmers use, for example, numeric values or *\_\_FILE\_\_* and *\_\_LINE\_\_* macros or predefined identifiers (e.g., C99 *\_\_func\_\_*) to identify the location of the block in the source file that may be causing a problem (during error reporting). None of this can be used together with the code automatically generated by the STM32CubeMX tools. An example of error handling from the automatically generated code for a demo project is (see file `main.c`):
```
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }
```

The error handler is called with no parameters to indicate what has happened or what the cause might be. The link register (LR) contains information about the program location from which the handler was called (program counter value). If this value is known, programmers can identify the source code part from the list file. Logging the LR value is easier than logging the \_\_FILE\_\_/ \_\_LINE\_\_ and uses only 8 bytes of the circular buffer. See below for the modified `Error_Handler()` function from the demo STM32H743 (file `main.c`).

```C
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void __attribute__((noinline)) __attribute__((__noreturn__)) Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

    // Log the location from which this function has been called
    uint32_t link_reg = __get_LR();
        // Get the address of the function from which the `Error_handler()` was called.
    RTE_MSG1(MSG1_ERROR_HANDLER, F_SYSTEM, link_reg - 5U)
        // 
    shutdown_the_system();
  /* USER CODE END Error_Handler_Debug */
}
```
The value -5 is subtracted because bit **0** of the address is always set to **1** (indicating Thumb-2 instruction mode) and because the `LR` (Link Register) points not to the function call of `Error_Handler()` but to the instruction immediately following it (PC+4).

The error-handling function must be declared with the `__attribute__((noinline))` attribute. This ensures that the function is always called and not inlined. Only under these conditions is it guaranteed that the `LR` (link register) will contain the address of the calling function.

The function `shutdown_the_system()` is just an example of what should be in well-written code instead of a typical `while(1)` endless loop.  When a problem is detected, the firmware should take decisive action (e.g., restart, halt, enter a safe operation mode, etc.) rather than getting stuck in an infinite loop. This function should not return to the caller (should also have the __noreturn__ attribute).

Format definition for RTE_MSG1() macro:
```
// MSG1_ERROR_HANDLER "Error_Handler() called from address 0x%08X"
```
The displayed address points to the instruction address that called Error_Handler(), as shown in the example below from the projects list file (compiled with GCC). <br>
```
24000508:	f7ff ffa2 	bl	24000450 <Error_Handler>
```


**Note:** If your compiler's library doesn't support `__get_LR()`, see also the function implementation in the RTEdbg demo code: [fault_handler.h](https://github.com/RTEdbg/RTEdbgDemo/blob/master/STM32H743/RTEdbg/Inc/fault_handler.h).

See also the complete list of **[Fault handler demo code](https://github.com/RTEdbg/RTEdbgDemo/blob/master/STM32H743/RTEdbg/Demo_code/Fault_handler.md)**.