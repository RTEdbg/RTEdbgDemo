# ARM Cortex-M4 / M7 Exception Handler Example

If a fatal error occurs while the debug probe is not connected, it is important to keep the most important information such as the CPU core dump and important global variables. The core dump can be logged using the *RTEdbg* library functions. The logged data allows you to analyze not only the error itself, but also the embedded system data and events that preceded the error, which may provide information about the cause of the error.

In the demo project folder is a common fault handler demo - see the file `fault_handler.c`. The fault handler logs fault information to the circular buffer. It replaces the default infinite loop in the startup file `startup_stm32____.s`. This fault handler can be used for all STM32 devices with either Cortex-M4 or Cortex-M7 core. Before using it for other Cortex-M7 and Cortex-M4 based processor families, you should review the fault handler and customize it if necessary. The programmer can add logging of other important information such as stack contents, important global variables and/or important RTOS variables, etc.

The handler logs the values of general and system CPU registers using the data logging functions of the *RTEdbg* library. Data logging is stopped by setting the message filter to zero. An automatic restart with the watchdog does not overwrite the data in the circular buffer unless the programmer requests it with the `rte_init()` or `rte_set_filter()` parameters (force buffer clear or force new filter value) - see *Locking Data Logging After a Fatal Error* in the RTEdbg manual. This data can be analyzed later when an automatic restart has already been performed and, for example, the host computer is connected to the embedded module. The hardware drivers and communication functions typically require a restart to reconnect to the host after a fatal error. The complete logged data (contents of the data logging structure) can also be written to internal or external flash memory.

**See also:**
1. The description of fault handler example for the ARM Cortex-M0/M0+ in **[Exception_handler_Cortex-M0.md](https://github.com/RTEdbg/RTEcomLib_NUCLEO_C071RB_Demo/blob/master/Exception_handler_Cortex-M0.md)**. This is an example of logging exception information with an even smaller memory footprint, suitable for bare-metal systems (systems without an RTOS). The complete program memory footprint of the code that prepares the exception data and calls the logging function is only about 40 bytes. The exception data is logged along with the stack dump, offering extra details about the code's execution before a fatal exception occurred.
2. The description of STM HAL Error_Handler data logging - see document **[HAL_Error_Handler.md](./HAL_Error_Handler.md)**. The demo code shows how to log information about the function that called `Error_Handler()` without needing to modify the code generated by the code generator.

Even a moderately sized data-logging buffer can log information about fatal errors and what the code was doing before the error occurred. This allows for efficient 'post-mortem' analysis. Additional information can be logged, if defined by the programmer, ranging from RTOS internals to task or system stack details and important system variables. A complete data structure or buffer can be logged with a single call to `RTE_MSGN()`. Note that the maximum size of a single message is limited. The compile time parameter `RTE_MAX_SUBPACKETS` defines how much information can be logged with a single logging macro.

**Note:** For the IAR EWARM and Keil MDK startup code versions, the exception handler entry code is implemented in the startup file (in assembly language). It calls `main_exception_handler()`.

The bus fault is triggered by the following line in `rtedbg_demo.c` and `simple_demo.c` to demonstrate the handler.
```
  #define INVALID_ADDRESS ((volatile uint32_t*)0x07000000)    // Bad address used to throw an exception

  (void)*INVALID_ADDRESS;        // Read from invalid address
```

### Format definitions
Exception data is logged with the `RTE_MSGN()` macro. The format definition for the ARM Cortex-M7 exception message logging is in the file **[cortex_M7_fault.h](../Fmt/cortex_M7_fault.h)**. Exception vector names are in the file **[cortex_M7_exceptions.txt](../Fmt/cortex_M7_exceptions.txt)**. 

The format definition for the ARM Cortex-M4 is in the file **[cortex_M4_fault.h](../../../STM32L433/RTEdbg/Fmt/cortex_M4_fault.h)** and exception vector names in the **[cortex_M4_exceptions.txt](../../../STM32L433/RTEdbg/Fmt/cortex_M4_exceptions.txt)**.

### Example of error data printed to the Main.log file after decoding the bus fault exception (ARM Cortex-M7)
```
N02804 603.797 MSGN_FATAL_EXCEPTION:   Register dump
  R00:0xFFFFFFF0, R01:0x00000012, R02:0x07000000, R03:0x0000012D
  R04:0x20000030, R05:0xFFFFFFE0, R06:0x00000064, R07:0x007594F5
  R08:0x00001FE9, R09:0xFA481A48, R10:0x0000000A, R11:0x20000000
  R12:0x00001335,  SP:0x2001FF28,  LR:0x00000675,  PC:0x00000684
  Status(xPSR = 0x21000000): ISR_No=0, Flags: Q=0, V=0, C=1, Z=0, N=0
  EXC_RETURN:0x000E9, BASEPRI:0x00000, CONTROL:0x00000
  CFSR:0x00008200:       
     Bus fault
        A data bus error has occurred, and the PC value stacked for the exception return
           points to the instruction that caused the fault.    
        Valid fault address       
  HFSR:0x40000000, ABFSR:0x00000000, Offending address:0x07000000
  ICSR:0x00000803, VECTACTIVE: 3-HardFault, VECTPENDING: 0-Thread mode
```
**Legend:**
* `N02804` - message number
* `603.797` - time [ms]
* `MSGN_FATAL_EXCEPTION` - format ID name